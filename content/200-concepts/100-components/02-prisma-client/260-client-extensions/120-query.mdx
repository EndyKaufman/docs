---
title: 'Create custom Prisma Client queries'
metaTitle: 'Prisma Client extensions (Preview)'
metaDescription: 'Extend the functionality of Prisma Client'
tocDepth: 3
---

<TopBlock>

<Admonition type="warning">

This page is in draft.

</Admonition>

From version 4.7.0, you can use `query` [Prisma Client extensions](/concepts/components/prisma-client/client-extensions) to create custom Prisma Client queries. These custom queries return type-safe data and, like all Prisma Client extensions, [run in isolated instances](/concepts/components/prisma-client/client-extensions#client-instances).

You can use `query` extensions as an alternative to [middlewares](/concepts/components/prisma-client/middleware#performance-and-appropriate-use-cases), with the advantages of user isolation and end-to-end type safety. [Learn more](#extensions-versus-middlewares).

Use the `$extends` [client-level method](/reference/api-reference/prisma-client-reference#client-methods) to create an _extended client_. An extended client is a forked variant of the standard Prisma Client with an extension applied. Use the `query` extension type to create custom queries to a specific model in your schema or to all models in your schema.

</TopBlock>

## Enable the preview feature

Before you create Prisma Client extensions, you must enable the `clientExtensions` feature flag in the `generator` block of your `schema.prisma` file, as follows:

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["clientExtensions"]
}
```

## Create custom queries

To create a custom query, use the following structure.

```ts
const xprisma = prisma.$extends({
  name?: 'name',
  query?: {
    user: { ... } //in this case, we add a query to the `user` model
  },
});
```

- `name`: an optional field that you can use to name the extension. This name appears in error logs.

In the following example, a custom query finds users who are older than 18 years:

```ts
const xprisma = prisma.$extends({
  query: {
    user: {
      async findMany({ model, action, args, data }) {
        args.where.age = { gt: 18 }
        const users = await data
        return data
      },
    },
  },
})

await xprisma.user.findMany() // returns users whose age is greater than 18
```

The `query` object contains functions that map to the names of the [Prisma Client operations](/docs/reference/api-reference/prisma-client-reference#model-queries), such as `findUnique`, `findFirst`, `findMany`, `count`, and `create`.

In the above example, a call to `xprisma.user.findMany` triggers `query.user.findMany` on execution. Each callback receives a type-safe `{ model, operation, args, data }` object that describes a query as follows:

- `model`: the property name of the model whose query is being extended.

  In the above example, the `model` is a string of type `"User"`.

- `operation`: the property name of the operation being extended and executed.

  In the above example, the `operation` is a string of type `"findMany"`.

- `args`: the property that carries the specific query input information to be extended.

  This is a type-safe object that is meant to be mutated before the query happens. You can mutate any of the properties in `args`, except for `include` or `select`, because that would change the expected output type in such a way that it breaks type safety.

- `data`: the property that a result promise of the query that is being executed.

  You can `await` and then mutate this promise, because its value is also type-safe. TypeScript catches any unsafe mutations on that object. Doing `await data` is equivalent to calling `next(...)` in a middleware. You are free to mutate `args` before `then` is triggered, which leads to a more natural way of writing such extensions. `args` is fully type-safe, meaning that some properties are `readonly`, (like `includes` or `select`).

### Nested queries

This is a declarative interface for hooking and extending queries, so you can also handle nested queries. `query` accepts wildcard operations to handle any levels of nesting.

The following hooks map to operation properties from Prisma Client operations to execute:

**!!! TBD - needs to be clarified !!! **

- `connect` / `connectOrCreate`
- `create` / `createMany`
- `delete` / `deleteMany`
- `select` / `include`
- `disconnect`
- `set`
- `update` / `updateMany`
- `upsert`
- `where`

These are not real operations, but are parts of a query that can be deeply nested or even applied with another model, such as with a relation query.

You can handle nested operations with the `$nestedOperations` option. You can recursively traverse the arguments of a given operation, as follows:

```ts
const xprisma = prisma.$extends({
  query: {
    user: {
      $nestedOperations: {
        where({ model, operation, args, data, path }) {
          // path here could be `user.findFirst`

          args.where.age = { gt: 18 }
        },
      },
    },
  },
})
```

** !!! Add a line about what we're showing here - what this does **

```ts
const xprisma = prisma.$extends({
  query: {
    user: {
      create({ model, operation, args, data, path }) {
        // handle all prisma.user.create

        return data
      },
      $nestedOperations: {
        create({ model, operation, args, path }) {
          // handle nested create for user
        },
      },
    },
  },
})
```

- `$nestedOperations`: an optional property that handles deeply nested operations.
- `path`: a property that describes the nesting level of such an operation.

## Add a custom query to all models in your schema

To extend all models in your schema, use `$allmodels` instead of a specific model name.

For example:

** TBA: explain what this following example does **

```ts
const xprisma = prisma.$extends({
  query: {
    $allModels: {
      $allOperations({ model, operation, args, data }) {
        // handle all operations

        return data
      },
      $nestedOperations: {
        create({ model, operation, args, data, path }) {
          // handle nested operations

          return data
        },
      },
    },
  },
})
```

Note: Recursive wildcards cannot return values but can just modify the query itself.

- `$allModels`: an optional property that handles all models in a single extension.
- `$allOperations`: an optional property that handles all operations for a given model.
- `$nestedOperations`: an optional property that handles specific nested operations.

## Query extensions versus middlewares

You can use either Client extensions or [middlewares](/concepts/components/prisma-client/middleware#performance-and-appropriate-use-cases) to hook into the query life-cycle and modify an incoming query or its result. Client extensions and middlewares differ in the following ways:

- Middlewares always apply globally to the same client. Client extensions are isolated, unless you deliberately combine them.
  - For example, in a row-level security (RLS) scenario, you can keep each user in an entirely separate client. With middlewares, all users are active in the same client.
- During application execution, with extensions you can choose from one or more extended clients, or the standard Prisma Client. With middlewares, you cannot choose which client to use, because there is only one global client.
- Extensions benefit from end-to-end type safety and inference, but middlewares don't.

You can use Prisma Client extensions in all scenarios where middlewares can be used.
